# 红包/优惠券方案设计



假定你是一名后端开发人员, 现在为一家饭店开发网上点餐系统.
饭店平时会发放一些红包或者优惠券, 请你设计一个红包/优惠券方案.



为了设计一个红包/优惠券方案，首先需要考虑饭店的营销目标、用户体验以及技术可行性。以下是一个可行的设计方案，涵盖了红包和优惠券的类型、规则和实现方式：

一、系统设计概述
红包/优惠券种类：

现金红包：一种以固定金额的形式发放的优惠，用户在结算时直接抵扣相应金额。

折扣券：按一定的折扣比例（如 10%、20% 等）给予优惠，结算时根据订单金额打折。

满减券：在消费金额达到一定值时，减免一定金额，例如“满100元减20元”。

赠品券：通过优惠券可以获得指定的赠品，如“买一送一”、“赠送饮料”等。



使用规则：

有效期：红包/优惠券通常有有效期，用户需在有效期内使用。

可叠加使用：系统可设置多个优惠券的叠加规则。可以设置是否允许多个红包/优惠券在同一订单中使用，或者每个订单仅限使用一张。

使用范围：红包/优惠券可以限定在特定商品、类别或订单金额范围内使用。

发放机制：

定期发放：饭店可以在节假日、促销活动期间发放红包或优惠券，吸引用户。

用户行为触发：比如用户首次注册、首次点餐、生日等活动时，可以发放红包或优惠券。

邀请奖励：用户邀请朋友注册或消费时，可以获得红包或优惠券作为奖励。

会员等级：根据会员等级，提供不同等级的红包或优惠券。VIP用户可以享受更大面额或更多种类的优惠。

------



### **红包/优惠券系统设计方案**

#### 一、 核心设计思想

1. 
2. **模板与实例分离**：
   - 
   - **优惠券模板 (Coupon Template)**：定义一种优惠券的通用规则，如“满100减10”、“新人专享5元无门槛红包”等。这是由饭店管理员创建的。
   - **用户优惠券 (User Coupon)**：是模板的一个具体实例，发放给某个特定用户。它有自己的生命周期（未使用、已使用、已过期）。
   - **好处**：这种设计可以轻松地创建和管理成千上万张发出去的优惠券，而规则定义只需要维护一份模板即可。
3. **规则引擎驱动**：
   - 
   - 将优惠券的使用条件（如最低消费、适用商品、有效期等）抽象成一系列可配置的规则。在用户结算时，后端通过一个“规则引擎”来判断哪些优惠券可用。
   - **好处**：未来增加新的优惠规则（如“仅限工作日使用”、“仅限指定套餐使用”）时，只需增加新的规则逻辑，而不需要改动核心数据结构。

#### 二、 红包/优惠券种类定义

我们将“红包”和“优惠券”统一为 **Coupon** 模型，通过 type 字段来区分其具体种类。

| 类型 (Type)         | 中文名称        | 描述                                               | 示例                             |
| ------------------- | --------------- | -------------------------------------------------- | -------------------------------- |
| CASH_VOUCHER        | **代金券/红包** | 直接减免固定金额，通常有使用门槛（最低消费）。     | “满100元减10元”、“无门槛5元红包” |
| PERCENTAGE_DISCOUNT | **折扣券**      | 按百分比进行折扣，通常会设置一个最高优惠金额上限。 | “全场8.8折券，最高优惠20元”      |
| FREE_ITEM           | 赠品券          | 免费兑换指定的菜品或商品。                         | “免费赠送一份【油酥烧饼】”       |
|                     |                 |                                                    |                                  |

#### 三、 数据模型设计 (Database Schema)

这是系统的核心，我们将设计两张主要的数据表。

**1. coupon_templates (优惠券模板表)**

这张表定义了优惠券长什么样。

| 字段名                   | 数据类型     | 说明                                                         | 示例                                                         |
| ------------------------ | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| id                       | BIGINT (PK)  | 唯一ID                                                       | 1                                                            |
| name                     | VARCHAR(100) | 优惠券名称，用于展示给用户                                   | “周末狂欢满100减15”                                          |
| type                     | VARCHAR(30)  | 优惠券类型 (上述的 CASH_VOUCHER, PERCENTAGE_DISCOUNT 等)     | CASH_VOUCHER                                                 |
| value                    | JSON         | **核心字段**：优惠券的具体数值。JSON格式提供了极高的灵活性。 | {"amount": 15} 或 {"percentage": 12, "max_off": 20} 或 {"dish_id": "d-123"} |
| usage_rules              | JSON         | **核心字段**：使用规则的集合。                               | {"min_spend": 100, "exclude_items": ["d-456"]}               |
| total_quantity           | INT          | 总发行量 (-1表示不限量)                                      | 5000                                                         |
| issued_quantity          | INT          | 已发行数量 (用于控制库存)                                    | 1234                                                         |
| validity_type            | VARCHAR(20)  | 有效期类型 (FIXED_DATE 或 RELATIVE_DAYS)                     | RELATIVE_DAYS                                                |
| valid_from / valid_until | DATETIME     | 如果是固定日期类型，则定义开始和结束时间。                   | 2023-10-01 / 2023-10-07                                      |
| valid_days_after_issue   | INT          | 如果是相对天数类型，定义领取后多少天内有效。                 | 7                                                            |
| status                   | VARCHAR(20)  | 模板状态 (ACTIVE, INACTIVE, EXPIRED)                         | ACTIVE                                                       |
| created_at / updated_at  | DATETIME     | 创建/更新时间                                                |                                                              |

**2. user_coupons (用户优惠券实例表)**

这张表记录了哪个用户拥有哪张优惠券。

| 字段名        | 数据类型    | 说明                                            | 示例                |
| ------------- | ----------- | ----------------------------------------------- | ------------------- |
| id            | BIGINT (PK) | 唯一ID                                          | 10001               |
| user_id       | BIGINT (FK) | 关联的用户ID                                    | u-9527              |
| template_id   | BIGINT (FK) | 关联的优惠券模板ID                              | 1                   |
| status        | VARCHAR(20) | 优惠券状态 (UNUSED, USED, EXPIRED)              | UNUSED              |
| acquired_at   | DATETIME    | 用户获取该优惠券的时间                          | 2023-09-30 10:00:00 |
| expires_at    | DATETIME    | **该实例的**具体过期时间 (根据模板规则计算得出) | 2023-10-07 10:00:00 |
| used_at       | DATETIME    | 使用时间                                        | NULL                |
| used_order_id | BIGINT      | 关联的使用订单ID                                | NULL                |

------



#### 四、 核心使用规则定义 (在 usage_rules JSON 字段中)

这些规则提供了强大的自定义能力。

| 规则 Key              | 描述                        | 示例                                              |
| --------------------- | --------------------------- | ------------------------------------------------- |
| min_spend             | **最低消费金额**            | 100 (消费满100元可用)                             |
| applicable_items      | **指定可用商品** (白名单)   | ["dish-101", "dish-102"] (仅烤鸭和凉皮可用)       |
| exclude_items         | **指定不可用商品** (黑名单) | ["dish-205"] (特价商品不可用)                     |
| applicable_categories | **指定可用分类**            | ["drinks", "cold-dishes"] (仅饮品和凉菜类可用)    |
| can_stack_with_others | **是否可叠加使用**          | false (通常不允许)                                |
| valid_time_slots      | **可用时间段**              | [{"start": "11:00", "end": "14:00"}] (仅午市可用) |
| valid_days_of_week    | **可用星期**                | [6, 7] (仅周六、日可用)                           |

#### 五、 核心业务流程

1. **发券流程 (Issuing)**
   - 
   - **场景1：新用户注册** -> 系统自动触发，为新用户创建一个 user_coupons 记录，关联到“新人专享”的 coupon_templates。
   - **场景2：活动页面领券** -> 用户点击领取，后端检查 coupon_templates 的 total_quantity 是否已超，未超则创建 user_coupons 记录并增加 issued_quantity。**此过程需要加锁，防止超发**。
   - **场景3：后台手动发放** -> 管理员为指定 user_id 创建一条 user_coupons 记录，用于补偿或客户关怀。
2. **用券流程 (Redemption)**
   - 
   - **Step 1: 查询可用券**
     - 
     - 用户在购物车/结算页面，前端请求 GET /api/me/coupons?order_amount=128&items=dish-101,dish-304。
     - 后端接收到订单信息（总价、商品列表等）。
     - 查询该用户所有 status = 'UNUSED' 的 user_coupons。
     - **遍历每一张券，送入“规则引擎”进行校验**：
       - 
       - 是否过期？ (expires_at)
       - 是否满足最低消费？ (min_spend)
       - 是否包含可用/禁用的商品？ (applicable_items / exclude_items)
       - 是否在可用时间段？ (valid_time_slots)
       - ...等等
     - 将校验通过的优惠券列表返回给前端。
   - **Step 2: 应用优惠券**
     - 
     - 用户选择一张优惠券。
     - 前端将 coupon_id (即 user_coupons.id) 随订单一起提交。
     - 后端在创建订单的**数据库事务**中：
       1. 
       2. **再次校验**该优惠券的可用性，防止在用户选择到提交的这段时间里，订单内容发生变化导致优惠券失效。
       3. 计算优惠后的订单金额。
       4. 创建订单记录。
       5. **将 user_coupons 的 status 更新为 USED**，并记录 used_at 和 used_order_id。
       6. 提交事务。

#### 六、 总结

这套方案通过**模板/实例模式**和**JSON规则字段**，实现了高度的灵活性和可扩展性。无论是简单的“5元红包”还是复杂的“仅限工作日午市烤鸭类商品可用的8折券”，都能通过配置 coupon_templates 表中的一条记录来轻松实现，无需修改后端代码。





------

每个红包/优惠券 可以有多条使用规则限制.

使用规则:
0. 有效期内使用
1. 订单总价满多少元 可以使用
2. 限定只针对某些单品可以使用折扣优惠
3. 针对总价折扣优惠
4. 限定只针对购买指定的菜品才能获取到赠品
5. 订单总价满多少元能获取到赠品
6. 是否可叠加使用：系统可设置多个优惠券的叠加规则。可以设置是否允许多个红包/优惠券在同一订单中使用，或者每个订单仅限使用一张。
7. 针对特定类别/ 特定商品 才可以使用
8. 这个 JSON 对象 {"max_off": 20, "percentage": 15} 是一个非常典型的折扣券规则定义，它表示一个**有最高优惠上限的折扣券**。

请根据以上内容设计实现红包使用规则方案.

当然可以。这是一个非常经典且重要的业务场景。基于您提出的具体规则，我将设计一个更为精细和灵活的红包/优惠券使用规则方案。

核心思想是采用**“策略模式（Strategy Pattern）”**和**“组合（Composition）”**的设计，将每一条规则视为一个独立的、可插拔的“策略”模块。在数据结构上，我们使用一个 `JSON` 字段来存储一个优惠券的所有规则组合。

---

### 一、 整体设计方案

1.  **统一规则接口**：所有的使用规则（如满减、商品限制）都遵循一个统一的数据结构。
2.  **规则组合**：一张优惠券的 `usage_rules` 字段是一个**规则对象的数组**。系统在校验时，会遍历这个数组，并逐一检查订单是否满足所有规则。
3.  **校验与应用分离**：
    *   **校验（Validation）**：判断一个订单**是否满足**使用该优惠券的所有前置条件。
    *   **应用（Application）**：如果校验通过，根据优惠券的类型（代金券、折扣券、赠品券）来**计算优惠金额或添加赠品**。

---

### 二、 数据模型增强

我们在之前的 `coupon_templates` 表的基础上，重点细化 `usage_rules` 字段的设计。

**`coupon_templates` 表 (重点字段)**

| 字段名            | 数据类型       | 说明                                                         |
| ----------------- | -------------- | ------------------------------------------------------------ |
| `id`              | `BIGINT` (PK)  | 模板ID                                                       |
| `name`            | `VARCHAR(100)` | 优惠券名称                                                   |
| `type`            | `VARCHAR(30)`  | **效果类型**: `CASH_VOUCHER`, `PERCENTAGE_DISCOUNT`, `FREE_ITEM` |
| `value`           | `JSON`         | **效果数值**: 如 `{"amount": 10}` 或 `{"percentage": 15}` 或 `{"gift_item_id": "dish-999"}` |
| **`usage_rules`** | **`JSONB`**    | **使用规则数组**。使用 `JSONB` 类型（在PostgreSQL中）可以获得更好的查询性能和索引支持。 |

---

### 三、 规则库 (Rule Library) 设计

这是本方案的核心。我们在 `usage_rules` 字段中存储一个对象数组，每个对象代表一条规则。

**规则对象基本结构:**

```json
{
  "rule_type": "RULE_NAME_HERE",
  "params": { ... }
}
```

下面我们根据您的要求，定义每一种 `rule_type`：

| 规则要求                               | `rule_type`                | `params` (JSON 对象)                                         | 说明                                                         |
| -------------------------------------- | -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 0. 有效期内使用                        | (不在此处定义)             | (无)                                                         | 这是优惠券实例 (`user_coupons`) 的基本属性 (`expires_at`)，在第一步就会被校验，不属于可配置的“使用规则”。 |
| 1. 订单总价满多少元可以使用            | `MINIMUM_SPEND`            | `{"amount": 100.00}`                                         | 订单商品总价必须 >= `amount`。                               |
| 2. / 7. 针对特定商品/类别才可使用      | `ITEM_ELIGIBILITY`         | `{"item_ids": ["d-101", "d-102"], "category_ids": ["cat-cold"], "logic": "ANY"}` | `logic`可以是`ANY`(满足任一即可)或`ALL`(必须全部满足)。此规则决定**整张券是否可用**。 |
| 3. 针对总价折扣优惠                    | (由 `type` 和其他规则决定) | (无)                                                         | 如果 `type` 是 `CASH_VOUCHER` 且**没有** `ITEM_DISCOUNT_SCOPE` 规则，则默认对总价生效。 |
| 2. (续) 限定只针对某些单品可以使用折扣 | `ITEM_DISCOUNT_SCOPE`      | `{"item_ids": ["d-101"], "category_ids": ["cat-roast-duck"]}` | **限定折扣计算范围**。例如，满100减10，但仅当这100元是来自烤鸭分类时才生效，或者折扣只作用于烤鸭。 |
| 4. 购买指定菜品才能获取赠品            | `CONDITIONAL_GIFT_ITEM`    | `{"required_item_ids": ["d-501"], "required_category_ids": ["cat-set-menu"]}` | **获取赠品的前提条件**。必须购买了指定商品/分类，才能触发赠品效果。需要与 `type: FREE_ITEM` 配合。 |
| 5. 订单总价满多少元能获取到赠品        | `SPEND_FOR_GIFT`           | `{"amount": 200.00}`                                         | **获取赠品的前提条件**。订单总价满 `amount` 才能触发赠品效果。需要与 `type: FREE_ITEM` 配合。 |
| 6. 是否可叠加使用                      | `STACKABILITY`             | `{"allow_stacking": false, "exclude_coupon_types": ["PERCENTAGE_DISCOUNT"]}` | `allow_stacking` 定义是否可与**任意**其他券叠加。<br/> `exclude_...` 定义不可与哪些类型的券叠加。 |

---

### 四、 综合示例

让我们通过几个例子来理解这套规则如何组合使用。

**示例 1：【新人专享】满68元减10元代金券，全场通用**

```json
// coupon_templates 表中的一条记录
{
  "name": "新人专享满68减10",
  "type": "CASH_VOUCHER",
  "value": { "amount": 10 },
  "usage_rules": [
    {
      "rule_type": "MINIMUM_SPEND",
      "params": { "amount": 68 }
    },
    {
      "rule_type": "STACKABILITY",
      "params": { "allow_stacking": false }
    }
  ]
}
```

**示例 2：【烤鸭节特惠】仅限烤鸭分类商品，满100元减20元**

```json
{
  "name": "烤鸭节满100减20",
  "type": "CASH_VOUCHER",
  "value": { "amount": 20 },
  "usage_rules": [
    {
      "rule_type": "MINIMUM_SPEND",
      "params": { "amount": 100 }
    },
    {
      // 规则1：限定这张券只在购买了烤鸭时才能被看到和使用
      "rule_type": "ITEM_ELIGIBILITY",
      "params": { "category_ids": ["cat-roast-duck"], "logic": "ANY" }
    },
    {
      // 规则2：限定优惠金额的计算范围也必须是烤鸭分类
      "rule_type": "ITEM_DISCOUNT_SCOPE",
      "params": { "category_ids": ["cat-roast-duck"] }
    },
    {
      "rule_type": "STACKABILITY",
      "params": { "allow_stacking": false }
    }
  ]
}
```
*   **场景分析**：一个订单里有`80元烤鸭` + `30元凉菜`，总价110元。
    *   `MINIMUM_SPEND` (100元) -> 通过。
    *   `ITEM_ELIGIBILITY` -> 通过，因为订单里有烤鸭。
    *   **应用优惠时**：系统会检查 `ITEM_DISCOUNT_SCOPE`，发现折扣只作用于烤鸭分类。订单中烤鸭部分消费为80元，不满足该范围内的100元满减条件，所以**最终无法使用**。
    *   如果订单是`120元烤鸭` + `30元凉菜`，总价150元，则可以使用，最终支付 `150 - 20 = 130元`。

**示例 3：【免费赠饮】购买任意主食，即可免费兑换一杯酸梅汤**

```json
{
  "name": "购买主食赠酸梅汤",
  "type": "FREE_ITEM", // 效果类型是赠品
  "value": { "gift_item_id": "d-901", "gift_item_name": "酸梅汤" }, // 效果值是赠品信息
  "usage_rules": [
    {
      // 规则：获取赠品的前提是购买了主食
      "rule_type": "CONDITIONAL_GIFT_ITEM",
      "params": { "required_category_ids": ["cat-main-course"] }
    }
  ]
}
```

---

### 五、 后端实现逻辑 (规则引擎)

后端需要一个 `CouponValidator` 服务来处理这一切。

```typescript
// 伪代码

class CouponValidator {
  
  /**
   * 校验一张优惠券是否对当前订单可用
   * @param order - 包含商品列表、总价等信息的订单对象
   * @param userCoupon - 用户持有的优惠券实例
   * @returns {boolean} - 是否可用
   */
  public isValid(order: Order, userCoupon: UserCoupon): boolean {
    const template = userCoupon.template; // 获取优惠券模板

    // 1. 基础校验：是否过期
    if (new Date() > userCoupon.expires_at) {
      return false;
    }

    // 2. 规则逐一校验
    for (const rule of template.usage_rules) {
      const isRuleSatisfied = this.checkRule(order, rule);
      if (!isRuleSatisfied) {
        return false; // 任何一条规则不满足，则整张券不可用
      }
    }

    return true; // 所有规则都满足
  }

  private checkRule(order: Order, rule: Rule): boolean {
    switch (rule.rule_type) {
      case 'MINIMUM_SPEND':
        return order.totalAmount >= rule.params.amount;
      
      case 'ITEM_ELIGIBILITY':
        // 复杂逻辑：检查订单中的商品ID/分类ID是否在 rule.params 中
        // ...
        return isItemEligible;
      
      case 'ITEM_DISCOUNT_SCOPE':
         // 在校验阶段，此规则通常返回 true，它主要在“应用”阶段起作用。
         // 或者在这里可以校验，适用范围内的商品总价是否满足另一个MINIMUM_SPEND
         return true;

      case 'CONDITIONAL_GIFT_ITEM':
        // 检查订单中是否包含 rule.params.required_item_ids 里的商品
        // ...
        return hasRequiredItems;
      
      // ... 其他规则的 case
    }
    return true;
  }
  
  /**
   * 应用优惠券，计算最终价格
   * @param order 
   * @param userCoupon 
   * @returns a new Order object with discount applied
   */
  public apply(order: Order, userCoupon: UserCoupon): Order {
      // ... 根据券的 type 和 value，以及 ITEM_DISCOUNT_SCOPE 等规则来计算最终折扣
      // ... 如果是 FREE_ITEM 类型，则向订单中添加赠品
      return discountedOrder;
  }
}
```

### 总结优势

*   **极高的灵活性**：未来如果需要增加新的规则（如“仅限周三使用”、“新用户专享”），只需定义一个新的 `rule_type` 并实现其校验逻辑，无需修改数据库表结构。
*   **清晰的职责分离**：每种规则逻辑内聚，易于开发、测试和维护。
*   **强大的组合能力**：可以自由组合各种规则，创造出运营活动所需的复杂优惠券。



------

您提了一个非常好的问题，这正是我设计方案中的核心所在！

实际上，我的方案中**确实包含了**一个代表单个红包/优惠券的表，我称之为 **`user_coupons` (用户优惠券实例表)**。

可能是我在之前的描述中没有足够强调，让您误以为只有 `coupon_templates` 这一张表。下面我详细解释一下为什么采用 **“模板 (Template)” + “实例 (Instance)”** 这种两层结构，以及它们各自的角色。

这种设计模式是业内处理此类问题的标准和最佳实践。

---

### 1. `coupon_templates` (优惠券模板表) - 它是“模具”

您可以把这张表想象成一个**“优惠券的模具”**或者**“印刷蓝图”**。

*   **它的作用是“定义”一种优惠券**。它规定了这种优惠券的所有通用属性和规则，例如：
    *   它叫什么名字？（“周末狂欢减20元券”）
    *   它能优惠多少？（类型是`CASH_VOUCHER`，数值是`20`元）
    *   它有什么使用限制？（`usage_rules`：必须满100元可用，不可与其它优惠叠加）
    *   它总共计划发行多少张？（`total_quantity: 5000`）
    *   用户领到后有效期是几天？（`valid_days_after_issue: 7`）

*   **谁来操作这张表？**
    *   饭店的运营或管理人员。当他们想发起一个新的优惠活动时，就在这张表里创建一条新的记录。

*   **为什么需要它？**
    *   **避免数据冗余**：假设您要发行1万张“满100减20”的券。如果没有模板表，您就需要在1万条记录里重复存储“满100减20”这个规则，这是巨大的浪费和冗余。有了模板表，这个规则只需要存一次。

---

### 2. `user_coupons` (用户优惠券表) - 它是“产品”

这张 `user_coupons` 表，就是您所说的**“红包/优惠券表”**。它代表了从“模具”中生产出来的、发放到**具体某个用户手上**的、**独一无二**的那个红包/优惠券。

*   **它的作用是“记录”一个优惠券实例**。它描述了一个具体优惠券的生命周期状态：
    *   **这张券属于谁？** (`user_id`)
    *   **这张券是什么类型的？** 它通过 `template_id` 关联到 `coupon_templates` 表，从而“继承”了该模板的所有规则。
    *   **这张券当前的状态是什么？** (`status`: `UNUSED`, `USED`, `EXPIRED`)
    *   **这张券具体的过期时间是什么时候？** (`expires_at`)。例如，模板规定“领取后7天有效”，如果用户A在10月1日领取，这条记录的 `expires_at` 就是10月8日；用户B在10月3日领取，她的记录 `expires_at` 就是10月10日。
    *   **这张券如果被使用了，用在了哪个订单上？** (`used_order_id`)

*   **谁来操作这张表？**
    *   主要是系统程序。当用户领取、使用或一张券过期时，程序会自动创建或更新这张表里的记录。

### 流程示例：一个完整的生命周期

让我们走一遍流程，看看这两张表是如何协同工作的：

1.  **创建活动 (操作 `coupon_templates`)**
    *   老板说：“国庆节搞个活动，发5000张满100减20的券，用户领到后7天内有效。”
    *   后端开发/运营人员在 `coupon_templates` 表里创建一条新记录，ID为 `101`，并填入所有规则。

2.  **用户领券 (创建 `user_coupons` 记录)**
    *   **用户A** 在10月1日上午10点，点击领取了这张券。
    *   系统会在 `user_coupons` 表里**创建一条新记录**：
        *   `user_id`: 用户A的ID
        *   `template_id`: `101`
        *   `status`: `UNUSED`
        *   `acquired_at`: `2023-10-01 10:00:00`
        *   `expires_at`: `2023-10-08 10:00:00` (根据模板计算得出)

    *   **用户B** 在10月2日下午3点，也领取了这张券。
    *   系统会**再创建一条全新的记录**在 `user_coupons` 表里：
        *   `user_id`: 用户B的ID
        *   `template_id`: `101`
        *   `status`: `UNUSED`
        *   `acquired_at`: `2023-10-02 15:00:00`
        *   `expires_at`: `2023-10-09 15:00:00`

3.  **用户用券 (更新 `user_coupons` 记录)**
    *   用户A在10月5日点了一份120元的烤鸭套餐。
    *   在结算时，系统：
        1.  查询 `user_coupons` 表，找到属于用户A的、状态为 `UNUSED` 且未过期的券。
        2.  通过这张券的 `template_id=101`，去 `coupon_templates` 表里查出使用规则（满100可用）。
        3.  发现订单金额120元 > 100元，校验通过！
        4.  用户A确认使用，订单总价变为 `120 - 20 = 100` 元。
        5.  系统**更新**用户A那条 `user_coupons` 记录的 `status` 为 `USED`，并记录下 `used_order_id`。

### 总结

| 表名                   | 角色          | 核心目的                                     | 类比           |
| ---------------------- | ------------- | -------------------------------------------- | -------------- |
| **`coupon_templates`** | **模板/定义** | 存储优惠券的**通用规则**，避免数据冗余。     | **模具、蓝图** |
| **`user_coupons`**     | **实例/记录** | 存储**每个用户持有**的优惠券的**具体状态**。 | **产品、实体** |

所以，**`coupon_templates`** 负责 **“是什么”**，而您关心的 **`user_coupons`** 表负责 **“谁有”** 和 **“怎么样了”**。这个设计方案是完整且健壮的。



------



# 如果这样设计 ,怎么向用户展示 哪些 优惠券/红包  当前用户可以领取?

这是一个非常好的实践问题，直接关系到用户体验和活动推广。在我的设计方案中，向用户展示“可领取的优惠券”是一个清晰且高效的流程。

这个场景的核心是：**我们需要从 `coupon_templates` (优惠券模板表) 中筛选出那些当前用户有资格领取，并且还在发放中的优惠券。**

下面是具体的实现步骤和后端逻辑：

---

### 一、 优惠券模板表 `coupon_templates` 需要补充的字段

为了支持“可领取中心”的功能，我们需要在 `coupon_templates` 表中确保有以下几个关键字段：

1.  **`status` (模板状态)**: `ENUM('ACTIVE', 'INACTIVE', 'FINISHED')`
    *   `ACTIVE`: 活动进行中，可以被用户看到和领取。
    *   `INACTIVE`: 草稿或已停用状态，用户不可见。
    *   `FINISHED`: 活动已结束（例如，已到期或已领完）。

2.  **`total_quantity` (总发行量)**: `INT`
    *   总共计划发行的数量。 `-1` 表示不限量。

3.  **`issued_quantity` (已领取数量)**: `INT`
    *   已经被用户领取的数量。这是一个计数器。

4.  **`issue_start_time` / `issue_end_time` (领券起止时间)**: `DATETIME`
    *   定义了这张优惠券可以在哪个时间段内被用户领取。这与用户使用优惠券的有效期是两回事。

5.  **`per_user_limit` (每人限领张数)**: `INT`
    *   每个用户最多可以领取多少张这种类型的优惠券。通常是 `1`。

6.  **`target_user_group` (目标用户群)**: `JSON` 或 `VARCHAR`
    *   **这是一个可选但非常有用的高级功能**。用于定义只有特定用户群体才能看到的券。例如：`{"type": "NEW_USER"}` (仅新用户可见) 或 `{"type": "USER_TAGS", "tags": ["VIP_LEVEL_3"]}` (仅VIP 3级用户可见)。

---

### 二、 后端API设计

我们需要创建一个专门的API来获取可领取的优惠券列表。

**API Endpoint:** `GET /api/coupons/claim-center`

**功能:** 返回当前登录用户可以领取的优惠券模板列表。

**后端处理逻辑 (伪代码):**

```typescript
async function getClaimableCoupons(userId: string): Promise<CouponTemplate[]> {
  
  // 1. 获取当前时间
  const now = new Date();

  // 2. 查询数据库，筛选出所有“可能”对用户可见的优惠券模板
  // SELECT * FROM coupon_templates WHERE ...
  const potentialTemplates = await db.coupon_templates.findMany({
    where: {
      // 条件a: 模板必须是活动状态
      status: 'ACTIVE',
      // 条件b: 领券时间必须在有效期内
      issue_start_time: { lte: now }, // lte: 小于等于
      issue_end_time: { gte: now },   // gte: 大于等于
      // 条件c: 券还没有被领完
      OR: [
        { total_quantity: -1 }, // 无限量
        { issued_quantity: { lt: db.raw('total_quantity') } } // 已领数量 < 总数量 (lt: 小于)
      ]
    }
  });

  if (!potentialTemplates.length) {
    return []; // 如果一个都没有，提前返回
  }
  
  // 3. 查询当前用户对这些模板的已领取数量
  // SELECT template_id, COUNT(*) as count FROM user_coupons WHERE user_id = ? AND template_id IN (...) GROUP BY template_id
  const userClaimedCounts = await db.user_coupons.groupBy({
    by: ['template_id'],
    where: {
      user_id: userId,
      template_id: { in: potentialTemplates.map(t => t.id) }
    },
    _count: {
      id: true
    }
  });
  // 结果可能像这样: [{ template_id: 101, _count: { id: 1 } }, { template_id: 102, _count: { id: 2 } }]

  // 将查询结果转换为更易于查找的 Map
  const claimedMap = new Map(userClaimedCounts.map(item => [item.template_id, item._count.id]));

  // 4. 最终筛选：遍历所有可能模板，排除用户已达领取上限的
  const claimableTemplates = potentialTemplates.filter(template => {
    const userHasClaimedCount = claimedMap.get(template.id) || 0;
    
    // 条件d: 用户已领取数量 < 每人限领张数
    if (userHasClaimedCount >= template.per_user_limit) {
      return false; // 用户已达领取上限，排除
    }
    
    // 条件e (高级): 检查用户是否属于目标用户群
    if (template.target_user_group) {
      const isUserTargeted = checkUserGroup(userId, template.target_user_group);
      if (!isUserTargeted) {
        return false; // 用户不符合目标人群，排除
      }
    }
    
    return true; // 通过所有检查，这张券可以被领取！
  });

  return claimableTemplates;
}
```

### 三、 前端展示

前端拿到 `GET /api/coupons/claim-center` 返回的 `claimableTemplates` 数组后，就可以遍历并渲染出“领券中心”的UI了。

*   对于每一张券，前端会展示其 `name`、`value` (如“10元”)、`usage_rules` (如“满100可用”)等信息。
*   旁边会有一个“立即领取”的按钮。
*   按钮的点击事件会触发另一个API调用： `POST /api/coupons/claim/{templateId}`。后端收到请求后，会执行之前讨论过的“发券流程”：检查库存、检查领取限制，然后为用户在 `user_coupons` 表中创建一条新记录。

### 总结

通过这个流程，我们可以完美地解决“如何向用户展示可领取的优惠券”的问题：

1.  **数据库层面**：在 `coupon_templates` 表中增加必要的字段来控制领券的资格和生命周期。
2.  **后端API层面**：创建一个专门的接口，通过多重条件过滤，精准地筛选出对**当前用户**可见且可领的优惠券列表。
3.  **用户资格校验**：核心校验逻辑包括：
    *   券本身是否在活动期 (`status`, `issue_time`)。
    *   券是否有库存 (`quantity`)。
    *   **当前用户**是否已达到领取上限 (`per_user_limit` vs `user_coupons` 记录)。
    *   **当前用户**是否属于特定目标人群 (`target_user_group`)。

这样设计，既能满足运营需求，又能保证系统的性能和数据的准确性。







# 数据库设计

使用Mysql



```
CREATE TABLE `coupon_templates` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '模板唯一ID',
  `name` VARCHAR(100) NOT NULL COMMENT '优惠券名称, 用于展示',
  `type` VARCHAR(30) NOT NULL COMMENT '优惠券类型: CASH_VOUCHER, PERCENTAGE_DISCOUNT, FREE_ITEM',
  `value` JSON NOT NULL COMMENT '优惠券效果的数值. e.g. {"amount": 10}, {"percentage": 12, "max_off": 20}, {"item_id": "d-123"}',
  `usage_rules` JSON NOT NULL COMMENT '使用规则集合, 采用JSON数组格式存储多个规则对象',
  
  -- 发放与库存控制
  `total_quantity` INT NOT NULL DEFAULT -1 COMMENT '总发行量, -1表示不限量',
  `issued_quantity` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '已发行/领取数量, 用于控制库存',
  `per_user_limit` INT UNSIGNED NOT NULL DEFAULT 1 COMMENT '每位用户限领张数',
  
  -- 领取时间控制
  `issue_start_time` DATETIME NULL DEFAULT NULL COMMENT '可领取的开始时间',
  `issue_end_time` DATETIME NULL DEFAULT NULL COMMENT '可领取的结束时间',

  -- 使用有效期定义
  `validity_type` VARCHAR(20) NOT NULL COMMENT '有效期类型: FIXED_DATE, RELATIVE_DAYS',
  `valid_from` DATETIME NULL DEFAULT NULL COMMENT '固定有效期 - 开始时间',
  `valid_until` DATETIME NULL DEFAULT NULL COMMENT '固定有效期 - 结束时间',
  `valid_days_after_issue` INT UNSIGNED NULL DEFAULT NULL COMMENT '相对有效期 - 领取后N天内有效',
  
  -- 状态与目标人群
  `status` VARCHAR(20) NOT NULL DEFAULT 'INACTIVE' COMMENT '模板状态: ACTIVE, INACTIVE, FINISHED',
  `target_user_group` JSON NULL COMMENT '目标用户群定义, e.g. {"type": "NEW_USER"}, {"type": "USER_TAGS", "tags": ["VIP"]}',

  -- 时间戳
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后更新时间',

  PRIMARY KEY (`id`),
  INDEX `idx_claim_center` (`status`, `issue_start_time`, `issue_end_time`) COMMENT '用于快速查询领券中心的可领取券'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='优惠券模板表';
```



```
CREATE TABLE `user_coupons` (
  `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '用户优惠券唯一ID',
  `user_id` BIGINT UNSIGNED NOT NULL COMMENT '关联的用户ID (应与用户表ID关联)',
  `template_id` BIGINT UNSIGNED NOT NULL COMMENT '关联的优惠券模板ID',
  `status` VARCHAR(20) NOT NULL DEFAULT 'UNUSED' COMMENT '优惠券状态: UNUSED, USED, EXPIRED',

  -- 生命周期时间
  `acquired_at` DATETIME NOT NULL COMMENT '用户获取该优惠券的时间',
  `expires_at` DATETIME NOT NULL COMMENT '该实例的具体过期时间 (根据模板规则计算得出)',
  `used_at` DATETIME NULL DEFAULT NULL COMMENT '使用时间 (使用后填充)',
  `used_order_id` BIGINT UNSIGNED NULL DEFAULT NULL COMMENT '关联的使用订单ID (使用后填充)',
  
  -- 时间戳
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后更新时间',

  PRIMARY KEY (`id`),
  INDEX `idx_user_status_expires` (`user_id`, `status`, `expires_at`) COMMENT '用于快速查询用户的可用优惠券',
  INDEX `idx_user_template` (`user_id`, `template_id`) COMMENT '用于快速检查用户对某个模板的领取数量',
  FOREIGN KEY (`template_id`) REFERENCES `coupon_templates`(`id`) ON DELETE RESTRICT ON UPDATE CASCADE
  -- 建议: FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ...
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='用户优惠券实例表';
```

